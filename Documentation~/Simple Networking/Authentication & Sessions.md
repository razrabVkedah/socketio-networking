# Вход и Регистрация

При первом запуске клиент генерирует guid и локально сохраняет его. При попытке установления соединения с сервером, клиент передаёт этот guid. Если guid уже существует в базе пользователей, то сервер “вспоминает” пользователя, иначе - сервер создает нового пользователя в базе данных.

> Данная библиотека разрабатывается для дальнейшей разработки под платформу ЯндексИгр, поэтому в качестве примера будет использоваться YandexId, но при желании можно переписать логику сервера под свои потребности

Но авторизация через guid не такая надежная, потому что клиент может зайти в игру с другого устройства и получить новый, совсем другой, аккаунт. Для это клиент может привязать свой YandexId. В случае привязки YandexId - к уже имеющемуся guid будет прикреплён YandexId, то есть guid так и останется основополагающим ключом, но также появится возможность авторизации через YandexId. И даже в случае смены устройства пользователь сможет получить доступ к своему аккаунт.

Также следует разобрать нестандартные сценарии:  
YandexId привязан к guid_1 на ПК. Пользователь заходит в игру с телефона (на телефоне изначально создаётся новый аккаунт) под guid_2. Пользователь некоторое время играет и потом вспоминает, что к телефону не привязан YandexId. Если пользователь решит привязать YandexId, он потеряет доступ к guid_2, потому что на телефоне выполнится авторизация с guid_1, - его следует предупредить об этом. Более подробная реализация: клиент отправляет guid_2 и YandexId - сервер узнает YandexId и отправляет клиенту guid, который связан с данным YandexId, то есть отправляет клиенту guid_1. Клиент получает guid_1 и локально сохраняет его для дальнейшего использования. Причем guid_2 теряется и больше не используется.  

Возможен такой сценарий, что для guid_1 уже существует активная сессия (например на ПК), тогда пользователь с телефона будет отключен от сервера после входа с помощью YandexId

# Менеджер сессий

Логика многопользовательских игр не подразумевает одновременного использования одного аккаунта с нескольких клиентов (устройств). Для контроля за клиентами сервер ведёт учёт активных сессий.

Для установления соединения с сервером, клиент отправляет свой guid (или YandexId) в качестве query параметра. Конечно, правильнее отправлять подобные данные внутри Auth, но BestSocketIo не имеет подобного функционала.

Если серверу поступает запрос на установление соединения и в запросе указан guid, то сервер проверяет наличие активной сессии для данного guid. Если сессия уже существует, соединение не устанавливается и новый клиент получает ошибку. Иначе, если активной сессии нет, то между клиентом и сервером устанавливается соединение по Socket.IO

# Ассиметричное шифрование

Гарантировать, что клиент в игре не будет подделан, действительно можно с использованием асимметричного шифрования, а также других методов обеспечения безопасности. Вот пошаговое объяснение, как это работает и как можно реализовать защиту:

### 1. Асимметричное шифрование

Асимметричное шифрование использует пару ключей: публичный и приватный. Публичный ключ используется для шифрования данных, а приватный — для их расшифровки.

### Основные принципы:

- **Публичный ключ**: Распространяется всем участникам, доступен публично.
- **Приватный ключ**: Держится в секрете и хранится на сервере.

### 2. Аутентификация клиента

Аутентификация клиента с использованием асимметричного шифрования помогает убедиться, что клиент не подделан.

### Пример процесса аутентификации:

1. **Регистрация**:
    - Клиент генерирует пару ключей (публичный и приватный).
    - Клиент отправляет публичный ключ на сервер и сохраняет приватный ключ на своей стороне.
2. **Аутентификация**:
    - Сервер генерирует случайное число (токен) и шифрует его публичным ключом клиента.
    - Клиент расшифровывает токен своим приватным ключом и отправляет его обратно на сервер.
    - Сервер проверяет, что токен верный, тем самым удостоверяясь, что клиент обладает приватным ключом и не является подделкой.

### 3. Подпись данных

Чтобы убедиться, что данные, отправленные клиентом, не были изменены, используется цифровая подпись.

### Процесс подписи данных:

1. Клиент генерирует хэш (например, с использованием SHA-256) от данных, которые он хочет отправить.
2. Клиент подписывает этот хэш своим приватным ключом, создавая цифровую подпись.
3. Клиент отправляет данные и цифровую подпись на сервер.
4. Сервер использует публичный ключ клиента, чтобы проверить подпись, убедившись, что данные не были изменены и действительно пришли от этого клиента.

### 4. Пример реализации в Unity

Для примера используем библиотеку `System.Security.Cryptography` для создания ключей, подписания и проверки данных.

### Генерация ключей:

```C#
using System.Security.Cryptography;
using System.Text;

public class CryptoUtils
{
    public static (string publicKey, string privateKey) GenerateKeys()
    {
        using (var rsa = new RSACryptoServiceProvider(2048))
        {
            var publicKey = Convert.ToBase64String(rsa.ExportCspBlob(false));
            var privateKey = Convert.ToBase64String(rsa.ExportCspBlob(true));
            return (publicKey, privateKey);
        }
    }
}
```

### Подписание данных:

```C#
public static string SignData(string data, string privateKey)
{
    using (var rsa = new RSACryptoServiceProvider(2048))
    {
        rsa.ImportCspBlob(Convert.FromBase64String(privateKey));
        var dataBytes = Encoding.UTF8.GetBytes(data);
        var signedBytes = rsa.SignData(dataBytes, CryptoConfig.MapNameToOID("SHA256"));
        return Convert.ToBase64String(signedBytes);
    }
}
```

### Проверка подписи:

```C#
public static bool VerifySignature(string data, string signature, string publicKey)
{
    using (var rsa = new RSACryptoServiceProvider(2048))
    {
        rsa.ImportCspBlob(Convert.FromBase64String(publicKey));
        var dataBytes = Encoding.UTF8.GetBytes(data);
        var signatureBytes = Convert.FromBase64String(signature);
        return rsa.VerifyData(dataBytes, CryptoConfig.MapNameToOID("SHA256"), signatureBytes);
    }
}
```

### 5. Интеграция в игровой процесс

### Регистрация клиента:

```C#
public class RegistrationManager : MonoBehaviour
{
    private string publicKey;
    private string privateKey;

    void Start()
    {
        (publicKey, privateKey) = CryptoUtils.GenerateKeys();
        // Отправьте публичный ключ на сервер для регистрации
    }
}
```

### Отправка данных с подписью:

```C#
public class NetworkManager : MonoBehaviour
{
    private string privateKey;

    void SendData(string data)
    {
        string signature = CryptoUtils.SignData(data, privateKey);
        // Отправьте data и signature на сервер
    }
}
```

### Проверка данных на сервере (псевдокод):

```C#
public class Server
{
    public void ReceiveData(string data, string signature, string clientPublicKey)
    {
        bool isValid = CryptoUtils.VerifySignature(data, signature, clientPublicKey);
        if (isValid)
        {
            // Обработка данных
        }
        else
        {
            // Отказ в обработке
        }
    }
}
```

### Важные аспекты:

1. **Защита ключей**: Приватный ключ должен быть надежно защищен на стороне клиента.
2. **Сертификация ключей**: Публичные ключи могут быть сертифицированы для дополнительной безопасности.
3. **SSL/TLS**: Использование SSL/TLS для шифрования всего трафика между клиентом и сервером.

### Заключение

Асимметричное шифрование позволяет гарантировать подлинность клиента и целостность данных, отправляемых между клиентом и сервером. Этот подход помогает защитить игру от подделки клиентов и манипуляции данными, обеспечивая безопасность и надежность игрового процесса.