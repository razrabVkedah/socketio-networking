Архитектура подразумевает наличие сервера, хоста и клиентов. Независимо от того, является ли сервер авторитарным, архитектура не меняется.

> Для неавторитарного сервера хостом выступает один из клиентов.

> Для авторитарного сервера хостом является запущенный на удалённом сервере билд (unity server platform)

Сервер (именно сервер, а не хост) выступает в роли связующего звена. Серверу нет дела до того, какие данные передавать. На данный момент подключение производиться к серверу, который взаимодействует с хостом. В дальнейшем добавится начальный уровень - сервер, отвечающий за региональное распределение. То есть клиент будет подключаться к серверу-распределителю, а затем к региональному серверу.

Инициатором передачи данных (независимо от авторитарности) выступает хост. То есть хост с определенной периодичностью обращается к серверу, а сервер передаёт данные клиентам. Причем у сервера есть защита от чрезмерного числа обращений как хоста, так и клиента.

Передача данных от клиентов реализована гибридно:  
1) данные, требующие регулярного обновления, передаются серверу с определенной периодичностью  
2) событийные данные передаются серверу сразу же  

# Network Update

Данное событие является основополагающим при передаче данных. В качестве родительского класса используется `BaseNetworkData`, у этого класса есть лишь одно поле `int dataType`  
В зависимости от значения этого поля родительский класс будет десериализован в определённый класс наследник.  

# Удалённый вызов методов (RPC)

По аналогии с NetworkUpdate, данный канал будет вызываться с определённой периодичностью (если есть данные, которые нужно передавать). Периодичность устанавливается сервером. НУЖНО ПРОДУМАТЬ, КАК ОБЕЗОПАСИТЬ СЕРВЕР ОТ ПЕРЕГРУЗОК.

Если клиент хочет отправить один и более RPC, данные RPC попадают в очередь и отправляются на сервер все вместе разом, когда наступит определенный момент.

Некоторые RPC могут иметь повышенный приоритет (Forced). Такие RPC отправляются на сервер незамедлительно. Во первых, только хост может установить какие RPC считаются Forced (это нужно чтобы избежать атак от обычных клиентов с изменённым кодом игры). Во вторых, даже для Forced RPC должны существовать ограничения на отправку - просто эти ограничения должны быть не такими строгими, как для цикличных RPC.

По задумке у клиента должна быть возможность выполнить код на стороне хоста. Причем метод должен вызваться у объекта-клиента, созданного у хоста.

Чтобы метод воспринимался как RPC, метод должен иметь атрибут [RPCAttribute]

# Network Variables

Данный канал предназначен для синхронизации полей классов удалённо.

Причем, не все поля класса для синхронизации будут передаваться через данный канал.  
Если у поля не указан режим синхронизации Forced, то информация об изменении данных в поле будет передавать в канале network-update, чтобы не перегружать сеть  

# Спавн

Хоть подобную логику и можно реализовать используя удалённый вызов методов, я считаю необходимым затронуть эту тему отдельно и создать отдельное решение конкретно для спавна.

Априори, объекты, которые будут создаваться во время игрового процесса, будут синхронизированы между клиентами до момента удаления этих самых объектов (или завершения работы комнаты).